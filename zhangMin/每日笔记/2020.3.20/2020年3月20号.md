**总结知识点**

**一,react生命周期**

React创建期
1.constructor

​     constructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使  用这两个参数时，需使用super()传入这两个参数。 

2.componentWillMount()

​     componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。 

3.render

​     render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。

4.componentDidMount()

​      组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染 

React更新期

1.componentWillReceiveProps

​       在接受父组件改变后的props需要重新渲染组件时用到的比较多

​       接受一个参数nextProps

​       通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件

2.shouldComponentUpdate(nextProps,nextState)

​        主要用于性能优化(部分更新)

​        唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会 进入重新渲染的流程，在这里return false可以阻止组件的更新

​        因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断

3.componentWillUpdate (nextProps,nextState)

​          shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入  componentWillUpdate,这里同样可以拿到nextProps和nextState。 

4.componentDidUpdate(prevProps,prevState)

​           组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。

React销毁期

1.componentWillUnmount ()

​            在此处完成组件的卸载和数据的销毁。

新的生命周期

1. getDerivedStateFromProps(nextProps, prevState)

        代替componentWillReceiveProps()。

老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。 

这两者最大的不同就是:
 在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。

1. 在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。
2. 而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。

2.getSnapshotBeforeUpdate(prevProps, prevState)

​             代替componentWillUpdate。
 常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。

这两者的区别在于：

1. 在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在
    componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。
2. getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。
    此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。

**二.css模块化**

​     1.模块化其实就是对类名进行修改，添加一些后缀，`styles.normal`本质上是一个字符串，只不过 是添加后缀之后的新类名，具体规则建议了解[BEM命名规范](https://www.w3cplus.com/css/bem-definitions.html) 

​     2.而模块化的编译原理就是对`:local`的编译，`:global`是不会被编译，同时也不能通过`styles`获取,只能字符串书写。

​     3.通过composes   //继承样式

**三.事件绑定**

- 合成事件
  -  React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用事件冒泡  的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理。 
-  事件绑定的this
  -  比较优化的事件绑定方式
    -  在constructor里的bind
    - 对象字面量函数
  -  下面两种方式会导致不必要的重新渲染   
    -  在render里bind
    -  箭头函数

-    改变this指向的方法
  -   通过bind来指明当前方法中的this指向当前组件 
  -   在构造函数constructor中改变this指向   
  -   使用箭头函数改变this指向      

