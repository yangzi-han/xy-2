***\*一 vue的生命周期\****

 vue的生命周期分为,数据初始化,dom挂载,数据更新,组件卸载,在一个就是组件 在开启了缓存,会有组件启用和停用阶段

 数据初始化阶段

  beforeCreate:在实例初始化后,数据观测和事件配置之前调用

  created:实例已经创建完成后调用   

  \2. dom挂在阶段

  beforeMount:DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示  

  这是因为Vue采用了Virtual DOM（虚拟Dom）技术。先占住了一个坑。

  mounted:数据和DOM都完成挂载

   \3.  数据更新阶段

​     beforeUpdate:数据更新之前调用

​     Updated:只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成  

​     beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发,在这里操     

​     作数据很影响性能和容易死循环。

​    \4.  缓存启用会用到下面两个钩子

​     activated:keep-alive组件激活是调用

​     deactivated:keep-alive组件停用时调用

​    \5.  组件卸载阶段

​     beforeDestroy:实例销毁之前调用

​     Destroyed:Vue实例销毁之后调用

  ***\*二 vue的组件通讯\****

​    ***\*1.父组件传子组件\****

​      单向数据流:props

​       使用ref访问子组件

​       使用$parent访问父组件

​       使用$children访问子组件

​       使用$root让问当前组件树的根实例

​       在template元素使用scoped可以访问到子组件中的slot元素的属性值

​     ***\*2.子组件传递数据给父组件\****

​       子组件通过事件给父组件传递数据,子组件通过$emit触发事件

​        父组件通过 $on监听事件

​     ***\*3.兄弟组件通信\****

​       用事件发布订阅

​       用vux

  ***\*三 vue路由实现原理\****

​     hash模式 和 history模式

​      hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash

​      用window.location.hash读取；

​      特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，

​      对服务端安全 无用，hash不会重加载页面。

​      hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com

​      因此对于 后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。

​      history模式：history采用HTML5的新特性；

​      且提供了两个新方法:pushState()  replaceState() 

​      可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。

​      history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致

​      如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误

   ***\*四 vue数据绑定原理\****

​     vue数据绑定主要采用了发布订阅者模式和数据劫持的方法,

​     通过Object.defineProperty来劫持各个属性的setter和getter,

​     在数据变动时发布消息给订阅者,触发相应的监听回调,具体就是

​     通过setter和getter来监听属性变动实现Observer进行数据的监听

​     然后就是通知订阅者,那么订阅者其实就是一个简单的数组,使用过的

​     数据可以通过getter得到,其实就是在调用的时候给数组里面添加了一个

​     订阅者,这样就实现了一个Watcher然后再实现一个compil其作用就是解析模板指令

​     将模板中的变量变成数据,然后初始化渲染页面视图,并将每个指令对应的节点

​     绑定更新函数,添加监听数据的订阅者,一旦数据有变动,收到通知,更新视图

​     其实vue的数据绑定根据mvvm作为数据绑定的入口,集合Observer,compil watcher,

​     通过Observer来监听自己的model数据变化,通过compil来解析模板指令

​     最终利用 Watcher来打架Observer和Compil之间的桥梁,达到数据变化,更新视图,

​     视图交互

   ***\*五 vuex是做什么的\****

​      Vuex是适用于Vuejs的状态管理库,为应用中的所有组件提供集中式的状态存储

​      与操作,保证了所有状态可以预测的方式进行修改

​      state:state定义了应用状态的数据结构,同样也可以在这里设置默认的初始状态

​      actions:actions即是定义提交触发更改信息的描述,常见的例子有从服务端

​      获取数据,,在获取数据完成以后会调用store.commit()来调用更改store中的状态

​      可以再组件中使用dispatch来发出Actions  

​      mutations:调用他是唯一允许更新应用状态的地方

​      getters:允许组件从Store中获取数据,例如我们可以从store中的projectlist中筛选出

​      已完成的项目列表

​      modules:允许将单一的store拆分成多个store的同时保存在单一的状态树中,随着 

​      应用的复杂度的增加,这种拆分能更好的组织代码

  ***\*六 $route和$router的区别\****

​     $route是路由信息对象,包含了path,params,query,hash,fullpath

​      matched,name这些路由参数

​      $router是路由实例对象包含路由的跳转方法,钩子函数等

  ***\*七 vue路由的钩子函数\****

​      官方称导航守卫可以控制导航的跳转,有beforeEach,afterEach等,

​      一般用于页面title的修改,一些需要登录才能调整页面的重定向功能,

​      beforeEach有 三个参数主要有:to,from,next

​      to:即将进入的目标,路由对象

​      from:当前导航正要离开的路由

​      next:一定要调用该方法来resolve这个钩子,执行效果依赖

​      next方法的调用参树,可以控制网页的跳转  

 ***\*八 v-if和v-show的区别\****  

​      v-if是直接销毁和重建dom达到让元素显示和隐藏的效果

​      v-show是通过修改元素的displayCss属性让其显示和隐藏

  

​      

​       

​      

 

 