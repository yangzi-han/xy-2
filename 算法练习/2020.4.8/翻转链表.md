//翻转链表
var reverseList = function(head) {
    let [prev, curr] = [null, head];
    while (curr) {
        let tmp = curr.next;    // 1. 临时存储当前指针后续内容
        curr.next = prev;       // 2. 反转链表
        prev = curr;            // 3. 接收反转结果
        curr = tmp;             // 4. 接回临时存储的后续内容
    }
    return prev;
};

//用队列实现栈
/**
 * Initialize your data structure here.
 */
var MyStack = function() {
    this.queue = [];
};

/**
 * Push element x onto stack. 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue.push(x);
};

/**
 * Removes the element on top of the stack and returns that element.
 * @return {number}
 */
MyStack.prototype.pop = function() {
    let res = [];
    for(let i=0;i<this.queue.length-1;i++){
        res.push(this.queue[i]);
    }
    let r = this.queue[this.queue.length-1];
    this.queue = res;
    return r;
};

/**
 * Get the top element.
 * @return {number}
 */
MyStack.prototype.top = function() {
    if(this.queue.length === 0) {
        return null;
    }
    return this.queue[this.queue.length-1];
};

/**
 * Returns whether the stack is empty.
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue.length === 0;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */

//合并排序数组
var merge = function(A, m, B, n) {
    let AIndex = m - 1;
    let BIndex = n - 1;   
    let current = m + n - 1;
    while (AIndex >= 0 && BIndex >= 0) {
        if (A[AIndex] <= B[BIndex]) {
            A[current] = B[BIndex]
            BIndex--
            current--
        } else {
            A[current] = A[AIndex]
            AIndex--
            current--
        }
    }
    //最后B剩余最小元素填充到A
    while (BIndex >= 0) {
        A[current] = B[BIndex]
        BIndex--;
        current--
    }
    

};
